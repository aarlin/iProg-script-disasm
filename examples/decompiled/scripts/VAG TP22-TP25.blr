

Editor
{
 (Caption="EEPROM";size=4096;mode=8;bytes=16)
}

Window(caption=""; width=800; height=680; align=h)
{
    Pages(left=5; top=0; width=850; height=1340)
    {
        Page(caption="Maker")
        {
            Group(caption="Crypt Key"; left=520; top=325; width=200; height=310)
            {
                Label(caption="Word"; name=label_0000; left=14; top=40; width=0; value=0)
                Label(caption="Crypt Key"; name=label_0001; left=74; top=40; width=0; value=0)
                Hexbytes(caption="9   "; name=hbWord9; left=30; top=70; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_0002; left=87; top=70; width=0; value=0)
                Button(caption="Write"; left=115; top=70; width=50; height=21; proc=writeWord9)
                Hexbytes(caption="8   "; name=hbWord8; left=30; top=110; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_0003; left=87; top=110; width=0; value=0)
                Button(caption="Write"; left=115; top=110; width=50; height=21; proc=writeWord8)
                Hexbytes(caption="7   "; name=hbWord7; left=30; top=150; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_0004; left=87; top=150; width=0; value=0)
                Button(caption="Write"; left=115; top=150; width=50; height=21; proc=writeWord7)
                Hexbytes(caption="6   "; name=hbWord6; left=30; top=190; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_0005; left=87; top=190; width=0; value=0)
                Button(caption="Write"; left=115; top=190; width=50; height=21; proc=writeWord6)
                Hexbytes(caption="5   "; name=hbWord5; left=30; top=230; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_0006; left=87; top=230; width=0; value=0)
                Button(caption="Write"; left=115; top=230; width=50; height=21; proc=writeWord5)
                Hexbytes(caption="4   "; name=hbWord4; left=30; top=270; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_0007; left=87; top=270; width=0; value=0)
                Button(caption="Write"; left=115; top=270; width=50; height=21; proc=writeWord4)
            }
            Group(caption="ID"; left=40; top=325; width=200; height=150)
            {
                Label(caption="Word"; name=label_0008; left=14; top=30; width=0; value=0)
                Label(caption="ID"; name=label_0009; left=70; top=30; width=0; value=0)
                Hexbytes(caption="3..2   "; name=hbBlock32; left=50; top=60; width=97; value=4; items="00 00 00 00")
                Button(caption="Read"; left=33; top=90; width=50; height=21; proc=ReadID)
                Button(caption="Write"; left=100; top=90; width=50; height=21; proc=WriteID)
            }
            Group(caption="User Data"; left=275; top=325; width=200; height=310)
            {
                Label(caption="Word"; name=label_000A; left=14; top=30; width=0; value=0)
                Label(caption="UM"; name=label_000B; left=70; top=30; width=0; value=0)
                Hexbytes(caption="1..0   "; name=hbBlock10; left=280; top=150; width=97; value=4; items="00 00 00 00")
                Hexbytes(caption="15   "; name=hbWord15; left=30; top=60; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_000C; left=87; top=60; width=0; value=0)
                Button(caption="Write"; left=115; top=60; width=50; height=21; proc=writeWord15)
                Hexbytes(caption="14   "; name=hbWord14; left=30; top=95; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_000D; left=87; top=95; width=0; value=0)
                Button(caption="Write"; left=115; top=95; width=50; height=21; proc=writeWord14)
                Hexbytes(caption="13   "; name=hbWord13; left=30; top=130; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_000E; left=87; top=130; width=0; value=0)
                Button(caption="Write"; left=115; top=130; width=50; height=21; proc=writeWord13)
                Hexbytes(caption="12   "; name=hbWord12; left=30; top=165; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_000F; left=87; top=165; width=0; value=0)
                Button(caption="Write"; left=115; top=165; width=50; height=21; proc=writeWord12)
                Hexbytes(caption="1   "; name=hbWord1; left=30; top=200; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_0010; left=87; top=200; width=0; value=0)
                Button(caption="Write"; left=115; top=200; width=50; height=21; proc=writeWord1)
                Hexbytes(caption="0   "; name=hbWord0; left=30; top=235; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_0011; left=87; top=235; width=0; value=0)
                Button(caption="Write"; left=115; top=235; width=50; height=21; proc=writeWord0)
                Button(caption="Read"; left=30; top=270; width=50; height=21; proc=readBlock1514)
                Label(caption="Bits"; name=label_0012; left=287; top=185; width=0; value=0)
                Label(caption="Lock Bits"; name=label_0013; left=317; top=185; width=0; value=0)
                Label(caption="  31"; name=label_0014; left=285; top=203; width=0; value=0)
                Label(caption="  30"; name=label_0015; left=285; top=223; width=0; value=0)
                Checkbox(caption="LB1"; name=cbLB1; left=315; top=205; value=0)
                Checkbox(caption="LB0"; name=cbLB0; left=315; top=225; value=0)
                Label(caption=" ................... "; name=label_0016; left=377; top=215; width=0; value=0)
                Button(caption="Write"; left=443; top=215; width=50; height=21; proc=writeLockBits)
                Label(caption="User Mem."; name=label_0017; left=317; top=250; width=0; value=0)
                Hexbytes(caption="29..0   "; name=hbUserMem; left=317; top=270; width=97; value=4; items="00 00 00 00")
                Label(caption=" ..... "; name=label_0018; left=418; top=270; width=0; value=0)
                Button(caption="Write"; left=442; top=270; width=50; height=21; proc=writeUserMem)
            }
            Group(caption="PIN"; left=40; top=485; width=200; height=150)
            {
                Label(caption="Word"; name=label_0019; left=14; top=30; width=0; value=0)
                Label(caption="PIN"; name=label_001A; left=70; top=30; width=0; value=0)
                Hexbytes(caption="11   "; name=hbWord11; left=30; top=60; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_001B; left=87; top=60; width=0; value=0)
                Button(caption="Write"; left=115; top=60; width=50; height=21; proc=writeWord11)
                Hexbytes(caption="10   "; name=hbWord10; left=30; top=95; width=49; value=2; items="00 00")
                Label(caption=" ..... "; name=label_001C; left=87; top=95; width=0; value=0)
                Button(caption="Write"; left=115; top=95; width=50; height=21; proc=writeWord10)
            }

            Group(caption="VAG TP22 - TP25"; left=45; top=10; width=280; height=200)
            {
                Button(caption="TP22 A3 (SEAT)"; left=50; top=30; width=165; height=25; proc=prepSEAT)
                Button(caption="TP23 A1  (VW)"; left=50; top=70; width=165; height=25; proc=prepVW)
                Button(caption="TP24 A4 (Skoda) "; left=50; top=110; width=165; height=25; proc=prepSKODA)
                Button(caption="TP25 A2 (Audi)"; left=50; top=150; width=165; height=25; proc=prepAUDI)
            }
            Group(caption="Key settings"; left=355; top=10; width=160; height=200)
            {
                List(caption="Key Number: "; name=KeyNumber; left=0x4B; top=40; width=80; value=0; items="select","Key 1","Key 2","Key 3","Key 4")
            }
            Group(caption="Status Key"; left=45; top=235; width=385; height=50)
            {
                Label(caption=" "; name=lbStatus; left=135; top=20; width=210; value=0)
            }
            Group(caption="Logo"; left=555; top=10; width=205; height=200)
            {
                Picture(caption="VAG.jpg"; left=35; top=30; width=0; height=0)
            }
        }
        Page(caption="Help")
        {
            Picture(caption="TP_2x.PNG"; left=150; top=0; width=0; height=0)
        }
    }
}

$HOST

emem eeprom=0,mismatch=2;

dword v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31;
dword b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13;
dword b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25;

proc unused_0000(){
	 v0 = 0;  v1 = 0;  v2 = 0;  v3 = 0;  v4 = 0;  v5 = 0;  v6 = 0;  v7 = 0;
	 v8 = 0;  v9 = 0; v10 = 0; v11 = 0; v12 = 0; v13 = 0; v14 = 0; v15 = 0;
	v16 = 0; v17 = 0; v18 = 0; v19 = 0; v20 = 0; v21 = 0; v22 = 0; v23 = 0;
	v24 = 0; v25 = 0; v26 = 0; v27 = 0; v28 = 0; v29 = 0; v30 = 0; v31 = 0;
	 b0 = 0;  b1 = 0;  b2 = 0;  b3 = 0;  b4 = 0;  b5 = 0;  b6 = 0;  b7 = 0;
	 b8 = 0;  b9 = 0;
	b11 = 0; b12 = 0; b13 = 0; b25 = 0;
	 
}

proc debug(){
	var a, i, n;
	a = device.dbg_timer;
	print("\nDBG_TIMER: " + #i.a);
	n = device.dbg_n;
	print("\nDBG_N: " + #i.n);
	print("\n");
	for(i = 0; i != n ;i++){
		a = device.dbgu[i];
		print("" + #i.a + " ");
		if (i & 0xF = 0xF)
			print("\n");
	}
	print("\n");
}

proc AUTH(){
	var a;
	print("\n Check adapter... ");
	device.pwr(3);
	delay(50);
	a = device.InitHTRC();
	delay(50);
	if(a = 1){
		print("not ready.");
		device.pwr(0);
		return(0);
	}
	print("OK.");
	
	a = device.Ast_Adjust(0x3F);
	
	for(a = 0; a < 144; a++) eeprom[a] = 0xFF;   // содержимое редактора = 0xFF
	
	a = device.Restart_Transponder();
	
	return(1);
}

///////////////// Crypt Key //////////////////

proc writeWord9()
{
	var a;
	a = AUTH();
	if (a = 0) return;

	device.InitFastTimer();	
	print("\n write Word 9(Crypt Key)..");
	
	hbWord9.color = 0xFFFFFF;
	
	//print("\n	write data..");
	a = device.WriteWord(9, hbWord9[0], hbWord9[1]);
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord9.color = 0x0000FF;
	}
	
	device.pwr(0);
}


proc writeWord8()
{
	var a;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write Word 8(Crypt Key)..");
	
	hbWord8.color = 0xFFFFFF;
	
	//print("\n	write data..");
	a = device.WriteWord(8, hbWord8[0], hbWord8[1]);
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord8.color = 0x0000FF;
	}
	
	device.pwr(0);
}

proc writeWord7()
{
	var a;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write Word 7(Crypt Key)..");
	
	hbWord7.color = 0xFFFFFF;
	
	//print("\n	write data..");
	a = device.WriteWord(7, hbWord7[0], hbWord7[1]);
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord7.color = 0x0000FF;
	}
	
	device.pwr(0);
}

proc writeWord6()
{
	var a;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write Word 6(Crypt Key)..");
	
	hbWord6.color = 0xFFFFFF;
	
	//print("\n	write data..");
	a = device.WriteWord(6, hbWord6[0], hbWord6[1]);
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord6.color = 0x0000FF;
	}
	
	device.pwr(0);
}

proc writeWord5()
{
	var a;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write Word 5(Crypt Key)..");
	
	hbWord5.color = 0xFFFFFF;
	
	//print("\n	write data..");
	a = device.WriteWord(5, hbWord5[0], hbWord5[1]);
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord5.color = 0x0000FF;
	}
	
	device.pwr(0);
}

proc writeWord4()
{
	var a;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write Word 4(Crypt Key)..");
	
	hbWord4.color = 0xFFFFFF;
	
	//print("\n	write data..");
	a = device.WriteWord(4, hbWord4[0], hbWord4[1]);
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord4.color = 0x0000FF;
	}
	
	device.pwr(0);
}

proc ReadID()
{
	var a, t;
	
	a = AUTH(); if(a = 0){ return; }
	device.InitFastTimer();
	
	print("\n    read ID..");
	hbBlock32.color = 0xFFFFFF;
	hbBlock32[0] = 0xFF;
	hbBlock32[1] = 0xFF;
	hbBlock32[2] = 0xFF;
	hbBlock32[3] = 0xFF;
		
	a = device.ReadBlock(0);
	if(a = 0)
	{
		print("Error!");
		hbBlock32.color = 0x0000FF;
	}
	else
	{
		t = device.tag_data; print(#h4.t);
		hbBlock32[0] = ((t >> 24) & 0xFF); 
		hbBlock32[1] = ((t >> 16) & 0xFF);
		hbBlock32[2] = ((t >> 8) & 0xFF);
		hbBlock32[3] = (t & 0xFF);
	}
	
	device.pwr(0);
}

///////////////// UM //////////////////
// 064D
proc RefreshCtrl_Block10(UMBlock)
{
	hbWord0[0] = ((UMBlock >> 24) & 0xFF);
	hbWord0[1] = ((UMBlock >> 16) & 0xFF);
	hbWord1[0] = ((UMBlock >> 8)  & 0xFF);
	hbWord1[1] = (UMBlock & 0xFF);
}

proc RefreshCtrl_LCKBits(UMBlock)
{
	if(UMBlock & 0x80000000)
	{
		cbLB1 = 1;
	}
	else
	{
		cbLB1 = 0;
	}
	
	if(UMBlock & 0x40000000)
	{
		cbLB0 = 1;
	}
	else
	{
		cbLB0 = 0;
	}
}

proc RefreshCtrl_UserMem(UMBlock)
{
	hbUserMem[0] = ((UMBlock >> 24) & 0x3F);
	hbUserMem[1] = ((UMBlock >> 16) & 0xFF);
	hbUserMem[2] = ((UMBlock >> 8)  & 0xFF);
	hbUserMem[3] = (UMBlock & 0xFF);
}

proc ResetCtrl_Block10()
{
	hbWord0[0] = 0xFF;
	hbWord0[1] = 0xFF;
	hbWord1[0] = 0xFF;
	hbWord1[1] = 0xFF;
}

proc ResetCtrl_LCKBits()
{
	cbLB1 = 1;
	cbLB0 = 1;
}

proc ResetCtrl_UserMem()
{
	hbUserMem[0] = 0xFF;
	hbUserMem[1] = 0xFF;
	hbUserMem[2] = 0xFF;
	hbUserMem[3] = 0xFF;
}

proc readBlock10()
{
	var a, t;
	
	a = AUTH(); if(a = 0){ return; }
	device.InitFastTimer();
	
	print("\n    read extra UM 1..0 ");
	
	hbWord1.color = 0xFFFFFF;
	hbWord0.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	
	a = device.ReadBlock_id7(0);
	if(a = 0)
	{
		print("Error!");
		hbWord1.color = 0x0000FF;
		hbWord0.color = 0x0000FF;
	}
	else
	{
		t = device.tag_data; print(#h4.t);
		hbWord1[0] = t >> 24 & 0xFF;
		hbWord1[1] = t >> 16 & 0xFF;
		hbWord0[0] = t >> 8 & 0xFF;
		hbWord0[1] = t & 0xFF;
	}

	device.pwr(0);
}

proc readBlock1213()
{
	var a, t;
	
	a = AUTH(); if(a = 0){ return; }
	device.InitFastTimer();
	
	print("\n    read extra UM 12..13 ");
	
	hbWord12.color = 0xFFFFFF;
	hbWord13.color = 0xFFFFFF;
	
	hbWord12[0] = 0xFF;
	hbWord12[1] = 0xFF;
	hbWord13[0] = 0xFF;
	hbWord13[1] = 0xFF;
	
	a = device.ReadBlock_id8(0);
	if(a = 0)
	{
		print("Error!");
		hbWord12.color = 0x0000FF;
		hbWord13.color = 0x0000FF;
	}
	else
	{
		t = device.tag_data; print(#h4.t);
		hbWord13[0] = t >> 24 & 0xFF;
		hbWord13[1] = t >> 16 & 0xFF;
		hbWord12[0] = t >> 8 & 0xFF;
		hbWord12[1] = t & 0xFF;
	}

	device.pwr(0);
	
	readBlock10();
}

proc readBlock1514()
{
	var a, t;
	
	a = AUTH(); if(a = 0){ return; }
	device.InitFastTimer();
	
	print("\n    read extra UM 15..14 ");
	
	hbWord14.color = 0xFFFFFF;
	hbWord15.color = 0xFFFFFF;
	
	hbWord14[0] = 0xFF;
	hbWord14[1] = 0xFF;
	hbWord15[0] = 0xFF;
	hbWord15[1] = 0xFF;
	
	a = device.ReadBlock_id9(0);
	if(a = 0)
	{
		print("Error!");
		hbWord14.color = 0x0000FF;
		hbWord15.color = 0x0000FF;
	}
	else
	{
		t = device.tag_data; print(#h4.t);
		hbWord15[0] = t >> 24 & 0xFF;
		hbWord15[1] = t >> 16 & 0xFF;
		hbWord14[0] = t >> 8 & 0xFF;
		hbWord14[1] = t & 0xFF;
	}

	device.pwr(0);

	readBlock1213();
}

proc writeWord15()
{
	var a, t, error;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write UM 15...");
	
	error = 0;
	
	hbWord15.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	ResetCtrl_LCKBits();
	ResetCtrl_UserMem();
	
	print("\n	write word 15.. ");
	a = device.WriteWord(15, hbWord15[0], hbWord15[1]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord15.color = 0x0000FF;
		error = 1;
	}

	device.pwr(0);
}

proc readUM()
{
	var a, t;
	
	a = AUTH(); if(a = 0){ return; }
	device.InitFastTimer();
	
	print("\n    read UM.. ");
	
	hbBlock10.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	ResetCtrl_Block10();
	ResetCtrl_LCKBits();
	ResetCtrl_UserMem();
	
	a = device.ReadBlock_id10(0);
	if(a = 0)
	{
		print("Error!");
		hbBlock10.color = 0x0000FF;
	}
	else
	{
		t = device.tag_data; print(#h4.t);
		RefreshCtrl_Block10(t);
		RefreshCtrl_LCKBits(t);
		RefreshCtrl_UserMem(t);
	}

	device.pwr(0);
}

proc writeWord14()
{
	var a, t, error;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write UM 14...");
	
	error = 0;
	
	hbWord14.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	ResetCtrl_LCKBits();
	ResetCtrl_UserMem();
	
	print("\n	write word 14.. ");
	a = device.WriteWord(14, hbWord14[0], hbWord14[1]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord14.color = 0x0000FF;
		error = 1;
	}

	device.pwr(0);
}

proc writeWord13()
{
	var a, t, error;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write UM 13...");
	
	error = 0;
	
	hbWord13.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	ResetCtrl_LCKBits();
	ResetCtrl_UserMem();
	
	print("\n	write word 13.. ");
	a = device.WriteWord(13, hbWord13[0], hbWord13[1]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord13.color = 0x0000FF;
		error = 1;
	}

	device.pwr(0);
}

proc writeWord12()
{
	var a, t, error;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write UM 12...");
	
	error = 0;
	
	hbWord12.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	ResetCtrl_LCKBits();
	ResetCtrl_UserMem();
	
	print("\n	write word 12.. ");
	a = device.WriteWord(12, hbWord12[0], hbWord12[1]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord12.color = 0x0000FF;
		error = 1;
	}

	device.pwr(0);
}

proc writeWord11()
{
	var a;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write Word 11..");
	
	hbWord11.color = 0xFFFFFF;
	
	a = device.WriteWord(11, hbWord11[0], hbWord11[1]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord11.color = 0x0000FF;
	}

	device.pwr(0);
}

proc writeWord10()
{
	var a;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write Word 10..");
	
	hbWord10.color = 0xFFFFFF;
	
	a = device.WriteWord(10, hbWord10[0], hbWord10[1]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord10.color = 0x0000FF;
	}

	device.pwr(0);
}

proc writeWord0()
{
	var a, t, error;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write UM 0...");
	
	error = 0;
	
	hbWord0.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	ResetCtrl_LCKBits();
	ResetCtrl_UserMem();
	
	print("\n	write word 0.. ");
	a = device.WriteWord(0, hbWord0[0], hbWord0[1]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord0.color = 0x0000FF;
		error = 1;
	}

	device.pwr(0);
}

proc writeWord1()
{
	var a, t, error;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write UM 1...");
	
	error = 0;
	
	hbWord1.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	ResetCtrl_LCKBits();
	ResetCtrl_UserMem();
	
	print("\n	write word 1.. ");
	a = device.WriteWord(1, hbWord1[0], hbWord1[1]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbWord1.color = 0x0000FF;
		error = 1;
	}

	device.pwr(0);
}

// 0F58
proc writeLockBits()
{
	var a, t, th, tl, error;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write Lock Bits...");
	
	error = 0;
	
	print("\n	read UM..");
	hbWord0.color = 0xFFFFFF;
	hbWord1.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	ResetCtrl_Block10();
	ResetCtrl_UserMem();
	
	a = device.ReadBlock_id7(0);
	//a = 0;
	if(a = 1)
	{
		//print("OK.");
		t = device.tag_data; print(#h4.t);
		t = (t >> 16) & 0x3FFF;
		//t = t | 0x8000;
		
		if(cbLB1 = 1){ t = t | 0x8000; }
		if(cbLB0 = 1){ t = t | 0x4000; }
		th = (t >> 8) & 0xFF;
		tl = t & 0xFF;
		print("\n	write word 0..");
		a = device.WriteWord(1, th , tl);
		if(a = 1)
		{
			print("OK.");
			print("\n	read UM..");
	
			a = device.ReadBlock_id7(0);
			if(a = 1)
			{
				t = device.tag_data; print(#h4.t);
				hbWord0.color = 0xFFFFFF;
				hbWord1.color = 0xFFFFFF;
				hbUserMem.color = 0xFFFFFF;
				RefreshCtrl_Block10(t);
				RefreshCtrl_LCKBits(t);
				RefreshCtrl_UserMem(t);
			}
			else
			{
				print("Error!");
			}
		}
		else
		{
			print("Error!");
		}
	}
	else
	{
		print("Error!");
		hbWord0.color = 0x0000FF;
		hbWord1.color = 0x0000FF;
		hbUserMem.color = 0x0000FF;
	}
	
	device.pwr(0);
	
	//debug_out();
}

proc writeUserMem()
{
	var a, t, error;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write User Mem...");
	
	error = 0;
	
	hbWord0.color = 0xFFFFFF;
	hbWord1.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	ResetCtrl_Block10();
	ResetCtrl_LCKBits();
	
	print("\n	write word 0.. ");
	a = device.WriteWord(0, hbUserMem[2], hbUserMem[3]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbUserMem.color = 0x0000FF;
		error = 1;
	}
	
	
	print("\n	write word 1.. ");
	t = (hbUserMem[0] & 0x3F) | 0x80;
	a = device.WriteWord(1, t, hbUserMem[1]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbUserMem.color = 0x0000FF;
		error = 1;
	}
	//device.pwr(0);
	//return;
	
	if(error = 0)		// не было ошибок? обновляем все поля
	{
		print("\n	update.. ");
		ResetCtrl_Block10();
		ResetCtrl_LCKBits();
		ResetCtrl_UserMem();
		a = device.ReadBlock_id7(0);
		//a = 0;
		if(a = 1)
		{
			print("OK.");
			t = device.tag_data;// print(#h4.t);
			RefreshCtrl_Block10(t);
			RefreshCtrl_LCKBits(t);
			RefreshCtrl_UserMem(t);
		}
		else
		{
			print("Error!");
			hbWord0.color = 0x0000FF;
			hbWord1.color = 0x0000FF;
			hbUserMem.color = 0x0000FF;
		}
	}
	device.pwr(0);
}


// 1293

proc writeID()
{
	var a, t, error;
	
	a = AUTH(); if(a = 0){ return; }
	
	device.InitFastTimer();
	print("\n write ID...");
	
	error = 0;
	
	hbBlock32.color = 0xFFFFFF;
	hbUserMem.color = 0xFFFFFF;
	ResetCtrl_LCKBits();
	ResetCtrl_UserMem();
	
	print("\n	write ID.. ");
	a = device.WriteWord(2, hbBlock32[2], hbBlock32[3]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbBlock32.color = 0x0000FF;
		error = 1;
	}
	
	
	print("\n	write ID.. ");
	a = device.WriteWord(3, hbBlock32[0], hbBlock32[1]);
	//a = 0;
	if(a = 1)
	{
		print("OK.");
	}
	else
	{
		print("Error!");
		hbBlock32.color = 0x0000FF;
		error = 1;
	}
	//device.pwr(0);
	//return;
	
	if(error = 0)		// не было ошибок? обновляем все поля
	{
		print("\n	update.. ");
		ResetCtrl_Block10();
		ResetCtrl_LCKBits();
		ResetCtrl_UserMem();
		a = device.ReadBlock(0);
		//a = 0;
		if(a = 1)
		{
			print("OK.");
			t = device.tag_data;// print(#h4.t);
			RefreshCtrl_Block10(t);
			RefreshCtrl_LCKBits(t);
			RefreshCtrl_UserMem(t);
		}
		else
		{
			print("Error!");
			hbBlock32.color = 0x0000FF;
			hbUserMem.color = 0x0000FF;
		}
	}
	device.pwr(0);
}


// 1403

proc prepSEAT_1()
{
	hbBlock32[0] = 0xAC;
	hbBlock32[1] = 0xFE;
	hbBlock32[2] = 0xF5;
	hbBlock32[3] = 0xB4;
	hbWord15[0] = 0x1A;
	hbWord15[1] = 0x2C;
	hbWord14[0] = 0x80;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x2A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0x38;
	hbWord5[1] = 0x4B;
	hbWord4[0] = 0x95;
	hbWord4[1] = 0x10;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP22 success!";
	lbStatus.color = 0xFF;
}

// 14AE
proc prepSEAT_2()
{
	hbBlock32[0] = 0x36;
	hbBlock32[1] = 0x12;
	hbBlock32[2] = 0xC9;
	hbBlock32[3] = 0xB9;
	hbWord15[0] = 0x1A;
	hbWord15[1] = 0x2C;
	hbWord14[0] = 0x80;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x2A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0x3C;
	hbWord5[1] = 0x06;
	hbWord4[0] = 0x10;
	hbWord4[1] = 0x90;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP22 success!";
	lbStatus.color = 0xFF;
}

// 1559
proc prepSEAT_3()
{
	hbBlock32[0] = 79;
	hbBlock32[1] = 244;
	hbBlock32[2] = 228;
	hbBlock32[3] = 43;
	hbWord15[0] = 168;
	hbWord15[1] = 63;
	hbWord14[0] = 144;
	hbWord14[1] = 0;
	hbWord13[0] = 0x2A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 206;
	hbWord5[1] = 51;
	hbWord4[0] = 129;
	hbWord4[1] = 0xE0;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP22 success!";
	lbStatus.color = 0xFF;
}

// 1604
proc prepSEAT_4()
{
	hbBlock32[0] = 58;
	hbBlock32[1] = 197;
	hbBlock32[2] = 112;
	hbBlock32[3] = 125;
	hbWord15[0] = 8;
	hbWord15[1] = 221;
	hbWord14[0] = 0;
	hbWord14[1] = 0;
	hbWord13[0] = 0x2A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0x42;
	hbWord5[1] = 0xDE;
	hbWord4[0] = 0xF3;
	hbWord4[1] = 0xE0;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP22 success!";
	lbStatus.color = 0xFF;
}

// 16af
proc prepVW_1()
{
	hbBlock32[0] = 0x8C;
	hbBlock32[1] = 0x5E;
	hbBlock32[2] = 0x94;
	hbBlock32[3] = 0x5B;
	hbWord15[0] = 0x81;
	hbWord15[1] = 0xCA;
	hbWord14[0] = 0x90;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x0A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0xB1;
	hbWord5[1] = 0x25;
	hbWord4[0] = 0x65;
	hbWord4[1] = 0x90;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP23 success!";
	lbStatus.color = 0xFF;
}

// 175a
proc prepVW_2()
{
	hbBlock32[0] = 0xDB;
	hbBlock32[1] = 0x55;
	hbBlock32[2] = 0xAB;
	hbBlock32[3] = 0xC5;
	hbWord15[0] = 0xD2;
	hbWord15[1] = 0xE2;
	hbWord14[0] = 0x30;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x0A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0x10;
	hbWord5[1] = 0xAF;
	hbWord4[0] = 0xA5;
	hbWord4[1] = 0x90;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP23 success!";
	lbStatus.color = 0xFF;
}

// 1805
proc prepVW_3()
{
	hbBlock32[0] = 0x0B;
	hbBlock32[1] = 0x32;
	hbBlock32[2] = 0x36;
	hbBlock32[3] = 0x0A;
	hbWord15[0] = 0x7B;
	hbWord15[1] = 0x50;
	hbWord14[0] = 0xA0;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x0A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0xA3;
	hbWord5[1] = 0xB7;
	hbWord4[0] = 0x63;
	hbWord4[1] = 0x30;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP23 success!";
	lbStatus.color = 0xFF;
}

// 18b0
proc prepVW_4()
{
	hbBlock32[0] = 0xAE;
	hbBlock32[1] = 0x6E;
	hbBlock32[2] = 0x63;
	hbBlock32[3] = 0x29;
	hbWord15[0] = 0xD1;
	hbWord15[1] = 0x24;
	hbWord14[0] = 0xA0;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x0A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0x6A;
	hbWord5[1] = 0xEE;
	hbWord4[0] = 0xA8;
	hbWord4[1] = 0x50;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP23 success!";
	lbStatus.color = 0xFF;
}

// 195b
proc prepSKODA_1()
{
	hbBlock32[0] = 0xD8;
	hbBlock32[1] = 0x2F;
	hbBlock32[2] = 0x57;
	hbBlock32[3] = 0x8C;
	hbWord15[0] = 0x5B;
	hbWord15[1] = 0xE6;
	hbWord14[0] = 0x70;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x32;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0xB6;
	hbWord5[1] = 0x64;
	hbWord4[0] = 0x8D;
	hbWord4[1] = 0x90;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP24 success!";
	lbStatus.color = 0xFF;
}

// 1a06
proc prepSKODA_2()
{
	hbBlock32[0] = 0x02;
	hbBlock32[1] = 0x32;
	hbBlock32[2] = 0xBC;
	hbBlock32[3] = 0x32;
	hbWord15[0] = 0xAE;
	hbWord15[1] = 0x59;
	hbWord14[0] = 0xA0;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x32;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0x7C;
	hbWord5[1] = 0x5A;
	hbWord4[0] = 0x9F;
	hbWord4[1] = 0xB0;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP24 success!";
	lbStatus.color = 0xFF;
}

// 1ab1
proc prepSKODA_3()
{
	hbBlock32[0] = 0xF9;
	hbBlock32[1] = 0xEB;
	hbBlock32[2] = 0x60;
	hbBlock32[3] = 0xD6;
	hbWord15[0] = 0x1C;
	hbWord15[1] = 0xE4;
	hbWord14[0] = 0xC0;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x32;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0x72;
	hbWord5[1] = 0x93;
	hbWord4[0] = 0xA1;
	hbWord4[1] = 0xA0;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP24 success!";
	lbStatus.color = 0xFF;
}

// 1b5c
proc prepSKODA_4()
{
	hbBlock32[0] = 0xDE;
	hbBlock32[1] = 0x04;
	hbBlock32[2] = 0x3C;
	hbBlock32[3] = 0x44;
	hbWord15[0] = 0xA2;
	hbWord15[1] = 0x8C;
	hbWord14[0] = 0xB0;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x32;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0xA9;
	hbWord5[1] = 0xD1;
	hbWord4[0] = 0x56;
	hbWord4[1] = 0x80;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP24 success!";
	lbStatus.color = 0xFF;
}

// 1c07
proc prepAUDI_1()
{
	hbBlock32[0] = 0x44;
	hbBlock32[1] = 0x46;
	hbBlock32[2] = 0xF2;
	hbBlock32[3] = 0x48;
	hbWord15[0] = 0x8F;
	hbWord15[1] = 0x3E;
	hbWord14[0] = 0x70;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x1A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0x38;
	hbWord5[1] = 0xE5;
	hbWord4[0] = 0xB3;
	hbWord4[1] = 0x00;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP24 success!";
	lbStatus.color = 0xFF;
}

// 1cb2
proc prepAUDI_2()
{
	hbBlock32[0] = 0x63;
	hbBlock32[1] = 0x2E;
	hbBlock32[2] = 0x7E;
	hbBlock32[3] = 0xAA;
	hbWord15[0] = 0x97;
	hbWord15[1] = 0x03;
	hbWord14[0] = 0xC0;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x1A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0xB3;
	hbWord5[1] = 0x6F;
	hbWord4[0] = 0xCF;
	hbWord4[1] = 0xA0;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP24 success!";
	lbStatus.color = 0xFF;
}

// 1d5d
proc prepAUDI_3()
{
	hbBlock32[0] = 0x91;
	hbBlock32[1] = 0x05;
	hbBlock32[2] = 0x7D;
	hbBlock32[3] = 0x04;
	hbWord15[0] = 0x9D;
	hbWord15[1] = 0x3B;
	hbWord14[0] = 0x20;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x1A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0x58;
	hbWord5[1] = 0xFC;
	hbWord4[0] = 0x67;
	hbWord4[1] = 0x00;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP24 success!";
	lbStatus.color = 0xFF;
}

// 1e08
proc prepAUDI_4()
{
	hbBlock32[0] = 0x05;
	hbBlock32[1] = 0xDB;
	hbBlock32[2] = 0x1D;
	hbBlock32[3] = 0xB8;
	hbWord15[0] = 0x61;
	hbWord15[1] = 0xCF;
	hbWord14[0] = 0xC0;
	hbWord14[1] = 0x00;
	hbWord13[0] = 0x1A;
	hbWord13[1] = 0x51;
	hbWord12[0] = 0x12;
	hbWord12[1] = 0xB3;
	hbWord5[0] = 0x8A;
	hbWord5[1] = 0x59;
	hbWord4[0] = 0x1F;
	hbWord4[1] = 0xF0;
	writeWord6();
	writeWord5();
	writeWord4();
	writeWord15();
	writeWord14();
	writeWord13();
	writeWord12();
	WriteID();	
	lbStatus = "Generate TP24 success!";
	lbStatus.color = 0xFF;
}

// 1eB3
proc prepSEAT()
{
	var a0, a1, a2, a3, a4, a5;
	
	mbox("Insert a blank megamos48w! \n          Press ok", 0);
	a0 = 0;
	ReadID();
	a1 = hbBlock32[0] << 16 | hbBlock32[1] << 8 | hbBlock32[1];
	if (a1 = 0xFFFFFF)
	{
		a0 = 1;
	}
	if (a0 = 1){
		lbStatus = "No transponder !";
		lbStatus.color = 0xFF;
	} else {
		a5 = 0;
		readUM();
		if (cbLB0 = 1) {
			a5 = 1;
		}
		if (a5 = 1) {
			mbox("Transponder bad", 0);
			lbStatus = "Replace transponder!";
			lbStatus.color = 0xFF;
			return;
		} else {
			if (KeyNumber = 0) {
				a4 = 1;
			}
			if (a4 = 1){
				mbox("Select number key", 0);
				return;
			}
			if (KeyNumber = 1){
				a4 = 1;
			}
			if (a4 = 1){
				prepSEAT_1();
				return;
			}
			if (KeyNumber = 2){
				a4 = 1;
			}
			if (a4 = 1){
				prepSEAT_2();
				return;
			}
			if (KeyNumber = 3){
				a4 = 1;
			}
			if (a4 = 1){
				prepSEAT_3();
				return;
			}
			if (KeyNumber = 4){
				a4 = 1;
			}
			if (a4 = 1){
				prepSEAT_4();
				return;
			}
		}
	}
}

// 1fe0
proc prepVW()
{
	var a0, a1, a2, a3, a4, a5;
	
	mbox("Insert a blank megamos48w! \n          Press ok", 0);
	a0 = 0;
	ReadID();
	a1 = hbBlock32[0] << 16 | hbBlock32[1] << 8 | hbBlock32[1];
	if (a1 = 0xFFFFFF)
	{
		a0 = 1;
	}
	if (a0 = 1){
		lbStatus = "No transponder !";
		lbStatus.color = 0xFF;
	} else {
		a5 = 0;
		readUM();
		if (cbLB0 = 1) {
			a5 = 1;
		}
		if (a5 = 1) {
			mbox("Transponder bad", 0);
			lbStatus = "Replace transponder!";
			lbStatus.color = 0xFF;
			return;
		} else {
			if (KeyNumber = 0) {
				a4 = 1;
			}
			if (a4 = 1){
				mbox("Select number key", 0);
				return;
			}
			if (KeyNumber = 1){
				a4 = 1;
			}
			if (a4 = 1){
				prepVW_1();
				return;
			}
			if (KeyNumber = 2){
				a4 = 1;
			}
			if (a4 = 1){
				prepVW_2();
				return;
			}
			if (KeyNumber = 3){
				a4 = 1;
			}
			if (a4 = 1){
				prepVW_3();
				return;
			}
			if (KeyNumber = 4){
				a4 = 1;
			}
			if (a4 = 1){
				prepVW_4();
				return;
			}
		}
	}
}

// 210d
proc prepSKODA()
{
	var a0, a1, a2, a3, a4, a5;
	
	mbox("Insert a blank megamos48w! \n          Press ok", 0);
	a0 = 0;
	ReadID();
	a1 = hbBlock32[0] << 16 | hbBlock32[1] << 8 | hbBlock32[1];
	if (a1 = 0xFFFFFF)
	{
		a0 = 1;
	}
	if (a0 = 1){
		lbStatus = "No transponder !";
		lbStatus.color = 0xFF;
	} else {
		a5 = 0;
		readUM();
		if (cbLB0 = 1) {
			a5 = 1;
		}
		if (a5 = 1) {
			mbox("Transponder bad", 0);
			lbStatus = "Replace transponder!";
			lbStatus.color = 0xFF;
			return;
		} else {
			if (KeyNumber = 0) {
				a4 = 1;
			}
			if (a4 = 1){
				mbox("Select number key", 0);
				return;
			}
			if (KeyNumber = 1){
				a4 = 1;
			}
			if (a4 = 1){
				prepSKODA_1();
				return;
			}
			if (KeyNumber = 2){
				a4 = 1;
			}
			if (a4 = 1){
				prepSKODA_2();
				return;
			}
			if (KeyNumber = 3){
				a4 = 1;
			}
			if (a4 = 1){
				prepSKODA_3();
				return;
			}
			if (KeyNumber = 4){
				a4 = 1;
			}
			if (a4 = 1){
				prepSKODA_4();
				return;
			}
		}
	}
}

// 223a
proc prepAUDI()
{
	var a0, a1, a2, a3, a4, a5;
	
	mbox("Insert a blank megamos48w! \n          Press ok", 0);
	a0 = 0;
	ReadID();
	a1 = hbBlock32[0] << 16 | hbBlock32[1] << 8 | hbBlock32[1];
	if (a1 = 0xFFFFFF)
	{
		a0 = 1;
	}
	if (a0 = 1){
		lbStatus = "No transponder !";
		lbStatus.color = 0xFF;
	} else {
		a5 = 0;
		readUM();
		if (cbLB0 = 1) {
			a5 = 1;
		}
		if (a5 = 1) {
			mbox("Transponder bad", 0);
			lbStatus = "Replace transponder!";
			lbStatus.color = 0xFF;
			return;
		} else {
			if (KeyNumber = 0) {
				a4 = 1;
			}
			if (a4 = 1){
				mbox("Select number key", 0);
				return;
			}
			if (KeyNumber = 1){
				a4 = 1;
			}
			if (a4 = 1){
				prepAUDI_1();
				return;
			}
			if (KeyNumber = 2){
				a4 = 1;
			}
			if (a4 = 1){
				prepAUDI_2();
				return;
			}
			if (KeyNumber = 3){
				a4 = 1;
			}
			if (a4 = 1){
				prepAUDI_3();
				return;
			}
			if (KeyNumber = 4){
				a4 = 1;
			}
			if (a4 = 1){
				prepAUDI_4();
				return;
			}
		}
	}
}

$DEVICE

#define DIN_H   PORTB |= (1<<5)
#define DIN_L   PORTB &= ((1<<5)^255)
#define SCLK_H  PORTB |= (1<<6)
#define SCLK_L  PORTB &= ((1<<6)^255)

#define DOUT_H  (PORTB & (1<<4)) != 0
#define DOUT_L  (PORTB & (1<<4)) = 0
#define DOUT_IN (PORTB & (1<<4))

#define SET_CONFIG_PAGE 	0x40
#define GET_CONFIG_PAGE 	0x04
#define WRITE_TAG       	0xC0
#define WRITE_TAG_N     	0x10
#define	READ_PHASE			0x08
#define	SET_SAMPLING_TIME	0x80

#define	FST_TMR_PER_T0	48			// Увеличение счетчика FAST_TIMER за время T0, при 

dword dbgu[1000];
dword dbg_n;
dword dbg_timer;

dword tag_data;
dword tag_data2;
byte sData[1000];
dword sLen;
byte dec_st;

proc status()
{
	return(POWER & 0x01);
}

//******************************** Megamos48 ************************************//

proc pwr(a)
{
    PWM0 = 0;
    POWER = a;
    if(a)   PWM0 = (4000000 << 7) | 64;
}

// отправка команды в трансивер
proc HTRCCmd(cmd)
{
    var i, cnt, mem;

    DIN_L; SCLK_L; SCLK_H; DIN_H; SCLK_L; DIN_L;    // инициализация
    
    if((cmd & 0xC0) = 0xC0) cnt = 3;        // если два старших бита команды установлены, то команда трехбитная
    else cnt = 8;

    mem = cmd & 0xF0;

    for(i = 0 ; i < cnt;i++)
    {
        if(cmd & 0x80)    DIN_H;
        else              DIN_L;
        SCLK_H; SCLK_L;
        cmd = cmd << 1;
    }
    DIN_L; 
    if(cnt = 3) return;  
    if(mem = 0)                         // если старшие 4 бита команды равны нулю, то команда имеет ответ
    {
        for(i = 0; i < 8; i++)
        {
            SCLK_H;
            cmd = cmd << 1;
            if(DOUT_H)  cmd |= 1;
            SCLK_L;
        }
        return(cmd & 255);
    }
}

// инициализация трансивера 
proc InitHTRC()
{
    var a;

	HTRCcmd(SET_CONFIG_PAGE + 0x00 + 0x02);
	HTRCcmd(SET_CONFIG_PAGE + 0x10 + 0x00);
	HTRCcmd(SET_CONFIG_PAGE + 0x20 + 0x00);
	HTRCcmd(SET_CONFIG_PAGE + 0x30 + 0x00);
	// читаем обратно нулевую страницу, чтобы проверить связь с трансивером
	a = HTRCcmd(GET_CONFIG_PAGE + 0x00);  if((a & 0x0F) != 0x02)	return (1);
	//a = HTRCcmd(GET_CONFIG_PAGE + 0x01);  if((a & 0x0F) != 0x00)	return (1);

	return (0);
}

proc Restart_Transponder()
{
	HTRCcmd(SET_CONFIG_PAGE + 0x10 + 0x01);		// switch off HTRC110 drivers/RF-field
	Delay(10000);
	HTRCcmd(SET_CONFIG_PAGE + 0x10 + 0x0);		// switch on HTRC110 drivers again
	Delay(2000);
	
	return (1);
}

proc Ast_Adjust(offset)
{
	var a;

	a = HTRCcmd(READ_PHASE);
	a = (a << 1);
	a = (a + offset);
	a = (a & 0x3F);
	HTRCcmd(SET_SAMPLING_TIME | a);
	
	return (1);
}

// proc_id4
proc InitFastTimer()
{
	FAST_TIMER_CLOCK = 1;		// 6 МГц
}

// 016C
proc InitCapture()
{
	var	a;
	
	// READ_TAG
	HTRCcmd(0x6A);
    HTRCcmd(0x6B);
    HTRCcmd(0x60);
    HTRCcmd(0xE0);
	
	//SET UP INTERVALS
    CAPT_INTERVAL0 = (4 << 16) | 8;           // 16To = 128mkc = 0x80/21.33 = 6.000
    CAPT_INTERVAL1 = (9 << 16) | 14;          // 32To = 256mkc = 256/21.33 = 12.000
	CAPT_INTERVAL2 = (14 << 16) | 21;           // 48To = 128mkc = 0x80/21.33 = 6.000
    CAPT_INTERVAL3 = (21 << 16) | 28;         // 64To = 512mkc = 512/21.33 = 24.000
    CAPT_INTERVAL4 = 0xFF;
	CAPT_INTERVAL5 = 0xFF;
	CAPT_INTERVAL6 = 0xFF;
	CAPT_INTERVAL7 = 0xFF;	
	
	//INIT CAPTURE MODE
    CAPT_MODE = 0;
    CAPT_CLOCK = 4;
	
	//dec_st = 0;
	
    IRQ_ENABLE = 1;		// разрешаем прерывание
}

// 01e2
proc DeInitCapture()
{
	IRQ_ENABLE = 0;
}

// proc_01F0
proc SearchLIW()	// 16 64 32 48
{
	var a, p, guard, result;
	
	
	dbg_n = 0;
	guard = 0;
	result = 0;
	dec_st = 0;
	
	a = IRQ_FLAG;	// Сбрасываем флаг прерывания!!!
	
	for(;;)
	{
		guard++;
		if(guard = 5000){ dec_st = 0; break; }
		if(IRQ_FLAG = 0) continue;
		
		p = CAPT_VALUE2 & 0x7F;
	
		dbgu[dbg_n] = p;
		dbg_n++;
	
		//continue;
		if(dec_st = 0)		// Wait 32 pulse
		{
			if(p = 1){ dec_st = 1; continue; }	// 32 pulse
			continue;
		}
		if(dec_st = 1)		// Wait 48 pulse
		{
			if(p = 1){ dec_st = 1; continue; }
			if(p = 2){ dec_st = 2; continue; }
			dec_st = 0; continue;
		}
		if(dec_st = 2)		// Wait 16 pulse
		{
			if(p = 0){ dec_st = 3; continue; }	// 16 pulse
			if(p = 1){ dec_st = 1; continue; }	// 32 pulse
			dec_st = 0; continue;
		}
		if(dec_st = 3)		// Wait 64 pulse
		{
			if(p = 1){ dec_st = 1; continue; }
			if(p = 3){ result = 1; break; }
			dec_st = 0; continue;
		}
	}
	
	FAST_TIMER = 0;
	
	return (result);
}

// proc_02F7
proc Read32BitManch()
{
	var a, p, t, guard, result, level, bt_cnt;
	

	dbg_n = 0;
	guard = 0;
	result = 0;
	bt_cnt = 0;
	dec_st = 0;
	level = 0;
	tag_data = 0;
	
	// Wait
	t = 171 * FST_TMR_PER_T0;	// Откалибровано!!! Сейчас от 164 до 178.
	while(FAST_TIMER < t);
	a = IRQ_FLAG;				// перед началом сбрасываем флаг прерывания
	a = 0;
	
	for(;;)
	{
		guard++;
		if(guard = 2000){ dec_st = 0; break; }
		if(IRQ_FLAG = 0) continue;
		
		p = CAPT_VALUE2 & 0x7F;
	
		dbgu[dbg_n] = p;
		dbg_n++;
		//continue;
		// Read Header
		if(dec_st = 0)	// читаем еденицы
		{
			if(p = 0)
			{
				a++; if(a = 15){ a = 0; dec_st = 1; } continue;
			}
			break;
		}
		if(dec_st = 1)	// переход на нули
		{
			if(p = 1){ dec_st = 2; continue; }
			break;
		}
		if(dec_st = 2)	// читаем нули
		{
			if(p = 0)
			{
				a++; if(a = 6){ a = 0; dec_st = 3; } continue;
			}
			break;
		}
		if(dec_st = 3)	// переход на данные
		{
			if(p = 0){ dec_st = 4; continue; }
			if(p = 1){ level ^= 1; dec_st = 5; continue; }
			break;
		}
		
		// Read Data
		if(dec_st = 4)	// Wait Short Interval
		{
			if(p = 0)	// Short Interval
			{
				if(bt_cnt = 31){ tag_data = ((tag_data << 1) | level); result = 1; break; }
				else{ dec_st = 5; continue; }
			}
			break;
		}
		if(dec_st = 5)	// Wait Any Interval
		{
			if(p = 0)	// Short Interval
			{
				tag_data = ((tag_data << 1) | level); bt_cnt++; dec_st = 4; continue;
			}
			if(p = 1)	// Long	Interval
			{
				tag_data = ((tag_data << 1) | level); level ^= 1; bt_cnt++;
				if(bt_cnt = 31){ tag_data = ((tag_data << 1) | level); result = 1; break; }
				else{ dec_st = 5; continue; }
			}
			break;
		}
	}
	
	FAST_TIMER = 0;
	
	return (result);
}





// proc_04a2
proc Read32BitManch2()
{
	var a, p, t, guard, result, level, bt_cnt;
	

	dbg_n = 0;
	guard = 0;
	result = 0;
	bt_cnt = 0;
	dec_st = 0;
	level = 0;
	tag_data = 0;
	
	// Wait
	t = 171 * FST_TMR_PER_T0;	// Откалибровано!!! Сейчас от 164 до 178.
	while(FAST_TIMER < t);
	a = IRQ_FLAG;				// перед началом сбрасываем флаг прерывания
	a = 0;

	for(;;)
	{
		guard++;
		if(guard = 2000){ dec_st = 0; break; }
		if(IRQ_FLAG = 0) continue;
		
		p = CAPT_VALUE2 & 0x7F;
	
		dbgu[dbg_n] = p;
		dbg_n++;
		//continue;
		// Read Header
		if(dec_st = 0)	// читаем еденицы
		{
			if(p = 0)
			{
				a++; if(a = 15){ a = 0; dec_st = 1; } continue;
			}
			break;
		}
		if(dec_st = 1)	// переход на нули
		{
			if(p = 1){ dec_st = 2; continue; }
			break;
		}
		if(dec_st = 2)	// читаем нули
		{
			if(p = 0)
			{
				a++; if(a = 6){ a = 0; dec_st = 3; } continue;
			}
			break;
		}
		if(dec_st = 3)	// переход на данные
		{
			if(p = 0){ dec_st = 4; continue; }
			if(p = 1){ level ^= 1; dec_st = 5; continue; }
			break;
		}
		
		// Read Data
		if(dec_st = 4)	// Wait Short Interval
		{
			if(p = 0)	// Short Interval
			{
				if(bt_cnt = 63){ tag_data = ((tag_data << 1) | level); result = 1; break; }
				else{ dec_st = 5; continue; }
			}
			break;
		}
		if(dec_st = 5)	// Wait Any Interval
		{
			if(p = 0)	// Short Interval
			{
				tag_data = ((tag_data << 1) | level); bt_cnt++; dec_st = 4; 
				if (bt_cnt = 32){
					tag_data2 = tag_data;
					tag_data = 0;
				}
				continue;
			}
			if(p = 1)	// Long	Interval
			{
				tag_data = ((tag_data << 1) | level); level ^= 1; bt_cnt++;
				if(bt_cnt = 32){
					tag_data2 = tag_data;
					tag_data = 0;
					//tag_data = ((tag_data << 1) | level); result = 1; break;
				}
				if (bt_cnt = 63) {
					tag_data = tag_data << 1 | level;
					result = 1;
					break;
				} else {
					dec_st = 5;
					continue;
				}
			}
			break;
		}
	}
	
	FAST_TIMER = 0;
	
	return (result);
}


// proc_0675
proc EncodeBits(Bits, Num)		
{
	var i;
	
	i = 0;
	while(i != Num)
	{
		if(Bits & 0x80000000){ sData[sLen] = 0x0; }
		else{ sData[sLen] = 0x70; }
		
		sLen++;
		Bits = Bits << 1;
		i++;
	}
}

// ID6
proc ReadBlock(block)	// block 0 - User Memory, block 1 - ID 
{
	var a, t;
	
	// PreInit
	STREAMPIN = PORTB.5;
	sLen = 0;
	
	// Prepare Stream
	if(block = 0)
	{
		EncodeBits(0xC000000, 6);		// Генерируем команду чтение UM блока
	}
	
	InitCapture();
	a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	
	// WRITE_TAG( прозрачный режим )
	HTRCcmd(0xC0);
	DIN_L;
	
	
	// Wait
	t = 110 * FST_TMR_PER_T0;	// Откалибровано!!! Сейчас от 100 до 130.
	while(FAST_TIMER < t);
	
	a = sLen * 8;
	StreamOut(sData, a, 32);
	FAST_TIMER = 0;
	
	
	InitCapture();
	dbg_timer = FAST_TIMER;
	dbg_timer = dbg_timer / FST_TMR_PER_T0;
	a = Read32BitManch();
	//a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	//dbg_timer = dbg_timer / FST_TMR_PER_T0;
	return (1);
	
}

proc ReadBlock_id7(block)
{
	var a, t;
	
	// PreInit
	STREAMPIN = PORTB.5;
	sLen = 0;
	
	// Prepare Stream
	if(block = 0)
	{
		EncodeBits(0x14000000, 6);		// Генерируем команду чтение UM блока
	}
	
	InitCapture();
	a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	
	// WRITE_TAG( прозрачный режим )
	HTRCcmd(0xC0);
	DIN_L;
	
	
	// Wait
	t = 110 * FST_TMR_PER_T0;	// Откалибровано!!! Сейчас от 100 до 130.
	while(FAST_TIMER < t);
	
	a = sLen * 8;
	StreamOut(sData, a, 32);
	FAST_TIMER = 0;
	
	
	InitCapture();
	dbg_timer = FAST_TIMER;
	dbg_timer = dbg_timer / FST_TMR_PER_T0;
	a = Read32BitManch();
	//a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	//dbg_timer = dbg_timer / FST_TMR_PER_T0;
	return (1);

}

proc ReadBlock_id8(block)
{
	var a, t;
	
	// PreInit
	STREAMPIN = PORTB.5;
	sLen = 0;
	
	// Prepare Stream
	if(block = 0)
	{
		EncodeBits(0x3C000000, 6);		// Генерируем команду чтение UM блока
	}
	
	InitCapture();
	a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	
	// WRITE_TAG( прозрачный режим )
	HTRCcmd(0xC0);
	DIN_L;
	
	
	// Wait
	t = 110 * FST_TMR_PER_T0;	// Откалибровано!!! Сейчас от 100 до 130.
	while(FAST_TIMER < t);
	
	a = sLen * 8;
	StreamOut(sData, a, 32);
	FAST_TIMER = 0;
	
	
	InitCapture();
	dbg_timer = FAST_TIMER;
	dbg_timer = dbg_timer / FST_TMR_PER_T0;
	a = Read32BitManch2();
	//a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	//dbg_timer = dbg_timer / FST_TMR_PER_T0;
	return (1);
	
}

proc ReadBlock_id9(block)
{
	var a, t;
	
	// PreInit
	STREAMPIN = PORTB.5;
	sLen = 0;
	
	// Prepare Stream
	if(block = 0)
	{
		EncodeBits(0x3C000000, 6);		// Генерируем команду чтение UM блока
	}
	
	InitCapture();
	a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	
	// WRITE_TAG( прозрачный режим )
	HTRCcmd(0xC0);
	DIN_L;
	
	
	// Wait
	t = 110 * FST_TMR_PER_T0;	// Откалибровано!!! Сейчас от 100 до 130.
	while(FAST_TIMER < t);
	
	a = sLen * 8;
	StreamOut(sData, a, 32);
	FAST_TIMER = 0;
	
	
	InitCapture();
	dbg_timer = FAST_TIMER;
	dbg_timer = dbg_timer / FST_TMR_PER_T0;
	a = Read32BitManch();
	//a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	//dbg_timer = dbg_timer / FST_TMR_PER_T0;
	return (1);
	
}


proc EncodeBitsWithParity(Bits, Num)		
{
	var i, parity;
	
	parity = 0;
	i = 0;
	while(i != Num)
	{
		parity = parity ^ Bits;
		if(Bits & 0x80000000){ sData[sLen] = 0x0; }
		else{ sData[sLen] = 0x70; }
		
		sLen++;
		Bits = Bits << 1;
		i++;
	}
	
	parity = parity & 0x80000000;
	if(parity = 0x80000000){ sData[sLen] = 0x0; }
	else{ sData[sLen] = 0x70; }
	sLen++;
}


// 09e0?
proc EncodeWriteCmd(Adr, HByte, LByte)
{
	var i, data, cparity;
	
	EncodeBits(0x28000000, 6);	// Генерируем команду записи слова
	
	Adr = ((Adr & 0xF) << 28);
	EncodeBitsWithParity(Adr, 4);
	
	data = (((HByte & 0xFF) << 24) | ((LByte & 0xFF) << 16));
	tag_data = data;
	
	cparity = 0;
	i = 0;
	while(i != 4)
	{
		cparity = cparity ^ data;
		EncodeBitsWithParity(data, 4);
		data = data << 4;
		i++;
	}
	
	cparity = cparity & 0xF0000000;
	EncodeBits(cparity, 5);
}



// 0a54?
proc CheckACK()	// 16 16 48 16 48 16
{
	var a, p, guard, result;
	
	dbg_n = 0;
	guard = 0;
	result = 0;
	dec_st = 0;
	
	a = IRQ_FLAG;	// Сбрасываем флаг прерывания!!!
	
	for(;;)
	{
		guard++;
		if(guard = 5000){ dec_st = 0; break; }
		if(IRQ_FLAG = 0) continue;
		
		p = CAPT_VALUE2 & 0x7F;
	
		dbgu[dbg_n] = p;
		dbg_n++;
	
		if(dec_st = 0)	// ждем импульс 16 * t0
		{
			if(p = 0){ dec_st = 1; continue; }	// импульс 16 * t0
			break;	// ошибка
		}
		if(dec_st = 1)	// ждем импульс 48 * t0
		{
			if(p = 2){ dec_st = 2; continue; }	// импульс 48 * t0
			break;	// ошибка
		}
		if(dec_st = 2)	// ждем импульс 16 * t0
		{
			if(p = 0){ dec_st = 3; continue; }	// импульс 16 * t0
			break;	// ошибка
		}
		if(dec_st = 3)	// ждем импульс 48 * t0
		{
			if(p = 2){ dec_st = 4; continue; }	// импульс 48 * t0
			break;	// ошибка
		}
		if(dec_st = 4)	// ждем импульс 16 * t0
		{
			if(p = 0){ result = 1; break; }	// импульс 16 * t0
			break;	// ошибка
		}
	}
	
	FAST_TIMER = 0;
	
	return (result);
}




// proc_id10
proc ReadBlock_id10(block)
{
	var a, t;
	
	// PreInit
	STREAMPIN = PORTB.5;
	sLen = 0;
	
	// Prepare Stream
	if(block = 0)
	{
		EncodeBits(0x14000000, 6);		// Генерируем команду чтение UM блока
	}
	else
	{
		EncodeBits(0x0C000000, 6);		// Генерируем команду чтения ID блока
	}
	
	InitCapture();
	a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	
	// WRITE_TAG( прозрачный режим )
	HTRCcmd(0xC0);
	DIN_L;
	
	
	// Wait
	t = 110 * FST_TMR_PER_T0;	// Откалибровано!!! Сейчас от 100 до 130.
	while(FAST_TIMER < t);
	
	a = sLen * 8;
	StreamOut(sData, a, 32);
	FAST_TIMER = 0;
	
	
	InitCapture();
	dbg_timer = FAST_TIMER;
	dbg_timer = dbg_timer / FST_TMR_PER_T0;
	a = Read32BitManch();
	//a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	//dbg_timer = dbg_timer / FST_TMR_PER_T0;
	return (1);
	
}

proc WriteWord(Adr, HByte, LByte)
{
	var a, t;
	
	// PreInit
	STREAMPIN = PORTB.5;
	sLen = 0;
	EncodeWriteCmd(Adr, HByte, LByte);
	
	InitCapture();
	a = SearchLIW();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	
	// WRITE_TAG( прозрачный режим )
	HTRCcmd(0xC0);
	DIN_L;
	
	// Wait
	t = 113 * FST_TMR_PER_T0;	// Откалибровано!!! Сейчас от 100 до 130.
	while(FAST_TIMER < t);
	
	a = sLen * 8;
	StreamOut(sData, a, 32);
	FAST_TIMER = 0;
	
	
	InitCapture();
	// Wait
	t = 183 * FST_TMR_PER_T0;	// Откалибровано!!! Сейчас от 176 до 192.
	while(FAST_TIMER < t);
	
	a = CheckACK();
	if(a = 0){ DeInitCapture(); return (0); }
	DeInitCapture();
	
	// Wait
	delay(25000);
	
	return (1);
}
